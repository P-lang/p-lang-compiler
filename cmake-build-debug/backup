enum TokenType {
    NUMBER,
    SPACE,
    TAB,
    WORD,
    OPERATOR_EQUALS,
    OPERATOR_PLUS,
    OPERATOR_MINUS,
    OPERATOR_MULTIPLY,
    OPERATOR_DIVIDE,
    OPERATOR_MORE,
    OPERATOR_LESS,
    OPERATOR_MORE_OR_EQUAL,
    OPERATOR_LESS_OR_EQUAL,
    COMMENT
};
const char* TokenTypeString[] = { "NUMBER\t\t", "SPACE\t\t", "TAB\t\t", "WORD\t\t", "OPERATOR_EQUALS\t", "OPERATOR_PLUS\t", "OPERATOR_MINUS\t", "OPERATOR_MULTIPLY", "OPERATOR_DIVIDE",
                                  "OPERATOR_MORE\t", "OPERATOR_LESS\t", "OPERATOR_MORE_OR_EQUAL", "OPERATOR_LESS_OR_EQUAL", "COMMENT\t\t" };

struct Token {
    TokenType tokenType;
    string value;
};

vector<Token> tokens;

void MakeToken(const string* source, TokenType tokenType, int startIndex, int length)
{
    Token token;
    token.tokenType = tokenType;
    token.value = source->substr(startIndex, length);
    tokens.push_back(token);

    //Log("Making token: " + string(to_string(startIndex)) + " -> " + to_string(length) + " Value: |" + token.value + "|");
}

void Tokenize(const string* source)
{
    Log("Tokenizing source.");

    enum {
        NORMAL,
        NUMBER,
        WORD,
        SPACE,
        COMMENT
    } state;
    int sourceLength = source->length();
    int currentIndex = 0;
    int tokenStartIndex = 0;

    char character = source->at(0);
    char characterNext = 0xFF;

    // Set initial state
    if((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z'))
    {
        state = WORD;
    }
    else if(character >= '0' && character <= '9')
    {
        state = NUMBER;
    }

    while(true)
    {
        int currentTokenLength = currentIndex - tokenStartIndex;

        // Check for end of source
        if(currentIndex >= sourceLength)
        {
            // Do something before ending -> make a token
            switch(state)
            {
                case NUMBER:
                    MakeToken(source, TokenType::NUMBER, tokenStartIndex, currentTokenLength);
                    break;
                case WORD:
                    MakeToken(source, TokenType::WORD, tokenStartIndex, currentTokenLength);
                    break;
            }
            break;
        }

        character = source->at(currentIndex);
        if(currentIndex+1 >= sourceLength)
        {
            characterNext = 0xFF;
        }
        else
        {
            characterNext = source->at(currentIndex+1);
        }

        // Not end of file, deal with current char
        switch(state)
        {
            // Check if state should be terminated based on char, if it does, make the token for the current state, and set the new state and start point.

            case NORMAL:
                if((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z'))
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex, currentTokenLength);
                    state = WORD;
                    tokenStartIndex = currentIndex;
                }
                else if(character >= '0' && character <= '9')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = NUMBER;
                    tokenStartIndex = currentIndex;
                }
                else if(character == '=')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_EQUALS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '+')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_PLUS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '-')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_MINUS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '>')
                {
                    if(characterNext == '=')
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_MORE_OR_EQUAL, tokenStartIndex,  2);
                        tokenStartIndex+=2;
                        currentIndex+=2;
                    }
                    else
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_MORE, tokenStartIndex,  1);
                        tokenStartIndex++;
                        currentIndex++;
                    }
                }
                else if(character == '<')
                {
                    if(characterNext == '=')
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_LESS_OR_EQUAL, tokenStartIndex,  2);
                        tokenStartIndex+=2;
                        currentIndex+=2;
                    }
                    else
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_LESS, tokenStartIndex,  1);
                        tokenStartIndex++;
                        currentIndex++;
                    }
                }
                else if(character == '/')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_DIVIDE, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '*')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_MULTIPLY, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '#')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = COMMENT;
                    tokenStartIndex = currentIndex;
                }
                else if(character == '\t')
                {
                    MakeToken(source, TokenType::TAB, tokenStartIndex,  1);
                    state = NORMAL;
                    tokenStartIndex = currentIndex;
                }

            // Most tokens start after space
            case SPACE:
                /*if(character == '\n' || character == '\r')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex, currentTokenLength);
                    state = WORD;
                    tokenStartIndex = currentIndex;
                }
                else */if((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z'))
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex, currentTokenLength);
                    state = WORD;
                    tokenStartIndex = currentIndex;
                }
                else if(character >= '0' && character <= '9')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = NUMBER;
                    tokenStartIndex = currentIndex;
                }
                else if(character == '=')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_EQUALS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '+')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_PLUS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '-')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_MINUS, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '>')
                {
                    if(characterNext == '=')
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_MORE_OR_EQUAL, tokenStartIndex,  2);
                        tokenStartIndex+=2;
                        currentIndex+=2;
                    }
                    else
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_MORE, tokenStartIndex,  1);
                        tokenStartIndex++;
                        currentIndex++;
                    }
                }
                else if(character == '<')
                {
                    if(characterNext == '=')
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_LESS_OR_EQUAL, tokenStartIndex,  2);
                        tokenStartIndex+=2;
                        currentIndex+=2;
                    }
                    else
                    {
                        MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                        state = SPACE;
                        tokenStartIndex = currentIndex;
                        MakeToken(source, TokenType::OPERATOR_LESS, tokenStartIndex,  1);
                        tokenStartIndex++;
                        currentIndex++;
                    }
                }
                else if(character == '/')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_DIVIDE, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '*')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::OPERATOR_MULTIPLY, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                else if(character == '#')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = COMMENT;
                    tokenStartIndex = currentIndex;
                }
                else if(character == '\t')
                {
                    MakeToken(source, TokenType::SPACE, tokenStartIndex,  currentTokenLength);
                    state = NORMAL;
                    tokenStartIndex = currentIndex;
                    MakeToken(source, TokenType::TAB, tokenStartIndex,  1);
                    tokenStartIndex++;
                    currentIndex++;
                }
                break;

            // Most tokens will end on space
            case WORD:
                if(character == ' ' || character == '\n' || character == '\r')
                {
                    MakeToken(source, TokenType::WORD, tokenStartIndex, currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                }
                break;

            case NUMBER:
                if(character == ' ' || character == '\n' || character == '\r')
                {
                    MakeToken(source, TokenType::NUMBER, tokenStartIndex, currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                }
                break;

            case COMMENT:
                if(character == '\n' || character == '\r')
                {
                    MakeToken(source, TokenType::COMMENT, tokenStartIndex, currentTokenLength);
                    state = SPACE;
                    tokenStartIndex = currentIndex;
                }
                break;


        }
        currentIndex++;
    }
}
